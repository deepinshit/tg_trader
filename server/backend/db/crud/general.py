# /backend/db/crud/general.py

"""
Generic async CRUD helpers for SQLAlchemy 2.0 ORM models.

- Works with models inheriting from DeclarativeBase.
- Keeps transaction boundaries controlled by the caller.
- Provides consistent logging and error handling.
"""

from __future__ import annotations

import logging
from typing import Type, Optional, Union, TypeVar, Any

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.exc import SQLAlchemyError, IntegrityError

from models import Base  # your DeclarativeBase

logger = logging.getLogger(__name__)

# Generic type for models inheriting from Base
T = TypeVar("T", bound=Base)


# --------------------------------------------------------------------------------------
# CREATE
# --------------------------------------------------------------------------------------
async def create(instance: T, session: AsyncSession) -> T:
    """
    Persist a new instance to the database.

    - Does NOT commit; caller manages transaction boundaries.
    - Flushes to push INSERT to DB and refreshes to load autogenerated fields.
    """
    try:
        session.add(instance)
        await session.flush()
        await session.refresh(instance)
        logger.debug("Created %s with id=%s", type(instance).__name__, getattr(instance, "id", None))
        return instance
    except IntegrityError:
        raise
    except SQLAlchemyError:
        logger.exception("Error creating %s", type(instance).__name__)
        raise


# --------------------------------------------------------------------------------------
# READ
# --------------------------------------------------------------------------------------
async def read(
    model: Type[T],
    session: AsyncSession,
    object_id: Optional[int] = None,
) -> Union[Optional[T], list[T]]:
    """
    Read objects from the database.

    Args:
        model: DeclarativeBase subclass.
        session: AsyncSession.
        object_id: Optional primary key.

    Returns:
        - A single instance or None if `object_id` is provided.
        - A list of instances otherwise.
    """
    try:
        if object_id is not None:
            obj = await session.get(model, object_id)
            logger.debug("Read %s id=%s -> %r", model.__name__, object_id, obj)
            return obj

        result = await session.execute(select(model))
        items = result.scalars().all()
        logger.debug("Read all %s -> %d rows", model.__name__, len(items))
        return items
    except SQLAlchemyError:
        logger.exception("Error reading %s (id=%r)", model.__name__, object_id)
        raise


# --------------------------------------------------------------------------------------
# UPDATE
# --------------------------------------------------------------------------------------
async def update(instance: T, session: AsyncSession) -> T:
    """
    Persist changes to an existing SQLAlchemy model instance.

    - Flushes and refreshes the instance.
    - Does not modify any attributes (assumes instance is already updated).

    Args:
        instance: SQLAlchemy model instance to persist.
        session: AsyncSession.

    Returns:
        The persisted instance.
    """
    try:
        session.add(instance)
        await session.flush()
        await session.refresh(instance)
        logger.debug(
            "Saved %s id=%s",
            instance.__class__.__name__,
            getattr(instance, "id", None),
        )
        return instance
    except SQLAlchemyError:
        logger.exception(
            "Error saving %s id=%s",
            instance.__class__.__name__,
            getattr(instance, "id", None),
        )
        raise

# --------------------------------------------------------------------------------------
# DELETE
# --------------------------------------------------------------------------------------
async def delete(model: Type[T], object_id: int, session: AsyncSession) -> bool:
    """
    Delete a row by primary key.

    Args:
        model: DeclarativeBase subclass.
        object_id: Primary key.
        session: AsyncSession.

    Returns:
        True if the row was deleted, False if not found.
    """
    try:
        obj = await session.get(model, object_id)
        if not obj:
            logger.debug("No %s found for id=%s; delete skipped", model.__name__, object_id)
            return False

        await session.delete(obj)
        await session.flush()
        logger.debug("Deleted %s id=%s", model.__name__, object_id)
        return True
    except SQLAlchemyError:
        logger.exception("Error deleting %s id=%s", model.__name__, object_id)
        raise
