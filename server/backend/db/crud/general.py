# /backend/db/crud/general.py

"""
Generic async CRUD helpers for SQLAlchemy 2.0 ORM models.

- Works with models inheriting from DeclarativeBase.
- Keeps transaction boundaries controlled by the caller.
- Provides consistent logging and error handling.
"""

from __future__ import annotations

import logging
from typing import Type, Optional, Union, TypeVar, Any

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.exc import SQLAlchemyError, IntegrityError

from models import Base  # your DeclarativeBase

logger = logging.getLogger(__name__)

# Generic type for models inheriting from Base
T = TypeVar("T", bound=Base)


# --------------------------------------------------------------------------------------
# CREATE
# --------------------------------------------------------------------------------------
async def create(instance: T, session: AsyncSession) -> T:
    """
    Persist a new instance to the database.

    - Does NOT commit; caller manages transaction boundaries.
    - Flushes to push INSERT to DB and refreshes to load autogenerated fields.
    """
    try:
        session.add(instance)
        await session.flush()
        await session.refresh(instance)
        logger.debug("Created %s with id=%s", type(instance).__name__, getattr(instance, "id", None))
        return instance
    except IntegrityError:
        raise
    except SQLAlchemyError:
        logger.exception("Error creating %s", type(instance).__name__)
        raise


# --------------------------------------------------------------------------------------
# READ
# --------------------------------------------------------------------------------------
async def read(
    model: Type[T],
    session: AsyncSession,
    object_id: Optional[int] = None,
) -> Union[Optional[T], list[T]]:
    """
    Read objects from the database.

    Args:
        model: DeclarativeBase subclass.
        session: AsyncSession.
        object_id: Optional primary key.

    Returns:
        - A single instance or None if `object_id` is provided.
        - A list of instances otherwise.
    """
    try:
        if object_id is not None:
            obj = await session.get(model, object_id)
            logger.debug("Read %s id=%s -> %r", model.__name__, object_id, obj)
            return obj

        result = await session.execute(select(model))
        items = result.scalars().all()
        logger.debug("Read all %s -> %d rows", model.__name__, len(items))
        return items
    except SQLAlchemyError:
        logger.exception("Error reading %s (id=%r)", model.__name__, object_id)
        raise


# --------------------------------------------------------------------------------------
# UPDATE
# --------------------------------------------------------------------------------------
async def update(
    model: Type[T],
    object_id: int,
    data: dict[str, Any],
    session: AsyncSession,
) -> Optional[T]:
    """
    Update an existing row with provided data.

    - Fetches DB object by `object_id`.
    - Applies only provided fields (ignores 'id').
    - Flushes and refreshes.

    Args:
        model: DeclarativeBase subclass.
        object_id: Primary key of row to update.
        data: Dict of fields to update.
        session: AsyncSession.

    Returns:
        Updated object or None if not found.
    """
    try:
        db_object = await session.get(model, object_id)
        if not db_object:
            logger.debug("No %s found for id=%s; update skipped", model.__name__, object_id)
            return None

        for key, value in data.items():
            if key != "id" and hasattr(db_object, key):
                setattr(db_object, key, value)

        session.add(db_object)
        await session.flush()
        await session.refresh(db_object)
        logger.debug("Updated %s id=%s with fields: %s", model.__name__, object_id, list(data.keys()))
        return db_object
    except SQLAlchemyError:
        logger.exception("Error updating %s id=%s", model.__name__, object_id)
        raise


# --------------------------------------------------------------------------------------
# DELETE
# --------------------------------------------------------------------------------------
async def delete(model: Type[T], object_id: int, session: AsyncSession) -> bool:
    """
    Delete a row by primary key.

    Args:
        model: DeclarativeBase subclass.
        object_id: Primary key.
        session: AsyncSession.

    Returns:
        True if the row was deleted, False if not found.
    """
    try:
        obj = await session.get(model, object_id)
        if not obj:
            logger.debug("No %s found for id=%s; delete skipped", model.__name__, object_id)
            return False

        await session.delete(obj)
        await session.flush()
        logger.debug("Deleted %s id=%s", model.__name__, object_id)
        return True
    except SQLAlchemyError:
        logger.exception("Error deleting %s id=%s", model.__name__, object_id)
        raise
